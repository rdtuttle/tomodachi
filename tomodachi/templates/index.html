<!DOCTYPE html>
<html>
<head>
    <title>Tomodachi - Virtual Pet</title>
    <style>
        :root {
            --bg: #2e2e2e;         /* dark gray background */
            --primary: #5d275d;    /* UI accent (kept) */
            --secondary: #b13e53;  /* UI accent (kept) */
            --accent: #38b764;     /* UI accent (kept) */
            --text: #f4f4f4;       /* light text */
            --pet: #000000;        /* black cat */
            --detail: #444444;     /* mid gray for panels / shadows */
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Helvetica', sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }


        /* Game card */
        .game-container {
            background: transparent;
            padding: 10px;
            margin: 20px;
            max-width: 700px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 18px;
        }

        /* Tamagotchi-like oval shell */
        .tamagotchi-shell {
            width: 420px;
            height: 520px;
            background: radial-gradient(circle at 30% 20%, #29407a 0%, #1b2b5b 45%, #0e1a39 100%);
            border-radius: 52% / 48%;
            box-shadow: 0 18px 40px rgba(0,0,0,0.6), inset 0 6px 18px rgba(255,255,255,0.02);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            padding-top: 28px;
        }

        /* Decorative logo at top of shell */
        .shell-logo {
            position: absolute;
            top: 14px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd95a;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: none;
            font-family: 'Comic Sans MS', 'Helvetica', sans-serif;
            font-size: 20px;
        }

        .screen {
            width: 300px;
            height: 300px;
            background: linear-gradient(180deg, #dbe7f7 0%, #f6f9ff 100%);
            border-radius: 12px;
            box-shadow: inset 0 6px 12px rgba(0,0,0,0.15);
            border: 8px solid #f0f4ff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .screen-window {
            width: 220px; height: 220px;
            background: repeating-linear-gradient(45deg, rgba(20,40,80,0.02) 0 6px, transparent 6px 12px);
            box-shadow: inset 0 6px 18px rgba(0,0,0,0.2);
            border-radius: 6px;
            display: flex; align-items: center; justify-content: center;
        }

        /* top/bottom icon rows inside the screen */
        .screen-top-icons, .screen-bottom-icons {
            width: 100%; display:flex; justify-content:space-around; padding:6px 8px; font-size:18px; opacity:0.95;
            color: #2b3a6f;
        }

        /* three pink control buttons like a Tamagotchi device */
        .shell-buttons {
            position: absolute;
            bottom: 26px;
            display: flex;
            gap: 16px;
            justify-content: center;
            width: 100%;
        }

        .shell-btn {
            width: 44px; height: 44px; border-radius: 50%;
            background: radial-gradient(circle at 30% 20%, #ff9ec9 0%, #ff6fa8 60%);
            border: 4px solid rgba(255,255,255,0.18);
            box-shadow: 0 6px 10px rgba(0,0,0,0.35), inset 0 2px 6px rgba(255,255,255,0.15);
            cursor: pointer;
        }

        .shell-btn:active { transform: translateY(2px); }

        /* Keep canvas pixelated and centered in the little screen window */
        #petCanvas { image-rendering: pixelated; width: 192px; height: 192px; }

        /* hide the legacy big button grids so the shell controls are primary */
        .buttons, .utility-buttons { display: none !important; }

        #petCanvas {
            image-rendering: pixelated;
        }

        .stats {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: var(--bg);
            border-radius: 8px;
        }

        .stat-label {
            color: var(--text);
            font-weight: bold;
        }

        .stat-bar {
            height: 10px;
            background: var(--detail);
            border-radius: 5px;
            overflow: hidden;
        }

        .stat-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .hunger-fill { background: var(--accent); }
        .happiness-fill { background: var(--primary); }
        .energy-fill { background: var(--secondary); }

        .buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            background: var(--primary);
            color: var(--text);
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            background: var(--secondary);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .utility-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .utility-buttons button {
            background: var(--detail);
        }

        .messages {
            color: var(--secondary);
            text-align: center;
            min-height: 20px;
            margin: 10px 0;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: var(--text);
            font-weight: 600;
        }

        .clock {
            font-variant-numeric: tabular-nums;
            opacity: 0.85;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }

        #petCanvas.alive {
            animation: float 3s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="tamagotchi-shell">
            <div class="shell-logo">Tomagotchi</div>

            <div class="screen">
                <div class="screen-top-icons" aria-hidden="true">üç¥ üí° üßΩ üíä</div>
                <div class="screen-window">
                    <!-- Keep the same canvas id so JS works unchanged -->
                    <canvas id="petCanvas" width="24" height="24"></canvas>
                </div>
                <div class="screen-bottom-icons" aria-hidden="true">üí§ üêæ üòä</div>
                <div style="position:absolute;right:12px;top:12px;color:#2b3a6f;font-weight:700;"> 
                    <div class="clock" id="clock">--:--</div>
                    <div id="dayDisplay" style="font-size:12px;opacity:0.9">Day 1</div>
                </div>
            </div>

            <div class="shell-buttons">
                <div style="display:flex;flex-direction:column;align-items:center;gap:6px;">
                    <div class="led" id="led-left" style="width:12px;height:8px;background:#2b3a6f;border-radius:4px;"></div>
                    <div class="shell-btn" id="btn-left" title="Feed"></div>
                </div>
                <div style="display:flex;flex-direction:column;align-items:center;gap:6px;">
                    <div class="led" id="led-center" style="width:12px;height:8px;background:#2b3a6f;border-radius:4px;"></div>
                    <div class="shell-btn" id="btn-center" title="Play"></div>
                </div>
                <div style="display:flex;flex-direction:column;align-items:center;gap:6px;">
                    <div class="led" id="led-right" style="width:12px;height:8px;background:#2b3a6f;border-radius:4px;"></div>
                    <div class="shell-btn" id="btn-right" title="Clean"></div>
                </div>
            </div>
            <!-- small dev gear to toggle fast-days -->
            <div style="position:absolute;left:12px;top:12px;">
                <button id="devToggle" style="background:transparent;border:none;color:#ffd95a;cursor:pointer;font-size:18px;">‚öôÔ∏è</button>
            </div>
        </div>

        <div class="stats">
            <span class="stat-label">Hunger</span>
            <div class="stat-bar">
                <div class="stat-fill hunger-fill" id="hungerBar"></div>
            </div>
            
            <span class="stat-label">Happiness</span>
            <div class="stat-bar">
                <div class="stat-fill happiness-fill" id="happinessBar"></div>
            </div>
            
            <span class="stat-label">Energy</span>
            <div class="stat-bar">
                <div class="stat-fill energy-fill" id="energyBar"></div>
            </div>

            <span class="stat-label">Litter</span>
            <div class="stat-bar">
                <div class="stat-fill" style="background:#c2b280" id="litterBar"></div>
            </div>
        </div>

        <div class="buttons">
            <button onclick="feed()">Feed</button>
            <button onclick="play()">Play</button>
            <button onclick="sleep()">Sleep</button>
            <button onclick="clean()">Clean</button>
        </div>

        <div class="buttons">
            <button onclick="discipline()">Discipline</button>
            <button onclick="attention()">Attention</button>
            <button onclick="sickcare()">Sick Care</button>
        </div>

        <div class="utility-buttons">
            <button onclick="save()">Save</button>
            <button onclick="load()">Load</button>
            <button onclick="showHelp()">Help</button>
        </div>

        <div class="messages" id="messages"></div>
    </div>

    <script>
    const PIXEL_SCALE = 8; // 24x24 at scale 8 -> 192px; fits in 400x300 canvas
    const SPRITES = {};
    const ANIMS = {};
    let currentPet = null;
    let animationFrame = null;
    let audioCtx = null;
    // animation state
    let currentAnim = { name: 'idle', frames: [], idx: 0, loop: true, frameMs: 180, lastT: 0, until: 0 };
    let nextIdleAt = 0;
    let petX = 120, petY = 70;

        // Build a more cat-like sprite and variants
        function cloneFrame(f){ return f.map(r=>r.slice()); }
        // Pixel values: 0=empty, 1=black fur, 2=shadow fur, 3=eye white, 4=tongue
        function emptyFrame(){ return Array(24).fill().map(()=>Array(24).fill(0)); }
        function makeCatBase(){
            const f = emptyFrame();
            // head (oval-ish, centered)
            for (let y=5;y<12;y++){
                for (let x=7;x<17;x++) f[y][x]=1;
            }
            // ears
            f[4][9]=1; f[5][8]=1; // left
            f[4][14]=1; f[5][15]=1; // right
            // cheeks
            f[11][7]=1; f[11][16]=1;
            // eyes (white with pupils)
            f[8][10]=3; f[8][11]=3; f[8][12]=3; f[8][13]=3; // whites
            f[8][11]=1; f[8][12]=1; // pupils centered
            // nose/mouth gap
            f[9][12]=0; f[10][12]=0;
            // body (sitting)
            for (let y=12;y<20;y++){
                for (let x=5;x<19;x++) f[y][x]=1;
            }
            // paws
            f[19][9]=1; f[19][14]=1;
            // tail base (left side)
            f[16][4]=1; f[15][4]=1;
            // soft shadow on lower-left areas
            for (let y=14;y<20;y++) f[y][6]=2;
            for (let y=13;y<18;y++) f[y][7]=2;
            return f;
        }
        function initSprites(){
            const base = makeCatBase();
            // variants
            const blink = cloneFrame(base); blink[8][10]=1; blink[8][11]=1; blink[8][12]=1; blink[8][13]=1; // eyes closed
            const tail_left = cloneFrame(base); tail_left[15][4]=1; tail_left[14][5]=1; tail_left[13][6]=1; // curve left
            const tail_right = cloneFrame(base); tail_right[16][6]=1; tail_right[15][7]=1; tail_right[14][8]=1; // curve right
            const lick1 = cloneFrame(base); lick1[10][12]=1; // mouth closed
            const lick2 = cloneFrame(base); lick2[10][12]=4; lick2[11][12]=4; // tongue out
            const stretch = cloneFrame(base);
            // stretch: raise paws
            stretch[18][9]=1; stretch[17][9]=1; stretch[18][14]=1; stretch[17][14]=1;
            const sleep1 = cloneFrame(base); sleep1[8][10]=1; sleep1[8][13]=1; // eyes closed
            const sleep2 = cloneFrame(sleep1); // chest up
            sleep2[14][12]=2; sleep2[14][13]=2;
            const walk1 = cloneFrame(base); walk1[19][10]=0; walk1[19][13]=0; walk1[18][10]=1; walk1[18][13]=1; // step
            const walk2 = cloneFrame(base); walk2[18][10]=0; walk2[18][13]=0; walk2[19][10]=1; walk2[19][13]=1;
            const dead = emptyFrame(); for(let y=5;y<12;y++){for(let x=7;x<17;x++){dead[y][x]=1}}; // head fill
            for (let x=10; x<14; x++){ dead[8][x]=0; }
            // ear twitch variants
            const ear1 = cloneFrame(base); ear1[4][9]=0; ear1[5][9]=1; // tilt left ear
            const ear2 = cloneFrame(base); ear2[4][14]=0; ear2[5][14]=1; // tilt right ear
            // kneading (alternate paws)
            const knead1 = cloneFrame(base); knead1[19][9]=0; knead1[18][9]=1;
            const knead2 = cloneFrame(base); knead2[19][14]=0; knead2[18][14]=1;

            // register frames
            Object.assign(SPRITES, {
                cat_idle: base,
                cat_blink: blink,
                cat_tailL: tail_left,
                cat_tailR: tail_right,
                cat_lick1: lick1,
                cat_lick2: lick2,
                cat_stretch: stretch,
                cat_sleep1: sleep1,
                cat_sleep2: sleep2,
                cat_walk1: walk1,
                cat_walk2: walk2,
                cat_ear1: ear1,
                cat_ear2: ear2,
                cat_knead1: knead1,
                cat_knead2: knead2,
                dead: dead,
            });

            // animations
            ANIMS.idle = { frames: ['cat_idle','cat_idle','cat_blink','cat_idle'], ms: 420, loop: true };
            ANIMS.tail = { frames: ['cat_tailL','cat_idle','cat_tailR','cat_idle'], ms: 160, loop: false };
            ANIMS.lick = { frames: ['cat_lick1','cat_lick2','cat_lick1','cat_idle'], ms: 180, loop: false };
            ANIMS.stretch = { frames: ['cat_idle','cat_stretch','cat_idle'], ms: 220, loop: false };
            ANIMS.sleep = { frames: ['cat_sleep1','cat_sleep2'], ms: 600, loop: true };
            ANIMS.walk = { frames: ['cat_walk1','cat_walk2'], ms: 140, loop: true };
            ANIMS.play = { frames: ['cat_tailL','cat_tailR','cat_tailL','cat_tailR'], ms: 120, loop: false };
            ANIMS.ears = { frames: ['cat_ear1','cat_idle','cat_ear2','cat_idle'], ms: 160, loop: false };
            ANIMS.knead = { frames: ['cat_knead1','cat_knead2','cat_knead1','cat_idle'], ms: 200, loop: false };
            ANIMS.eat = ANIMS.lick;
            // unique action animations (used with overlays)
            ANIMS.discipline = { frames: ['cat_ear1','cat_ear2','cat_ear1','cat_idle'], ms: 140, loop: false };
            ANIMS.attention = { frames: ['cat_knead1','cat_knead2','cat_knead1','cat_idle'], ms: 160, loop: false };
            ANIMS.sick = { frames: ['cat_sleep1','cat_sleep2','cat_sleep1','cat_idle'], ms: 220, loop: false };
        }

        function colorFor(v){
            const styles = getComputedStyle(document.body);
            if (v === 1) return styles.getPropertyValue('--pet');
            if (v === 2) return '#111111';
            if (v === 3) return styles.getPropertyValue('--text');
            if (v === 4) return '#e88888';
            return null;
        }

        function drawSpriteFrame(ctx, sprite, offsetX = petX, offsetY = petY) {
            const h = sprite.length;
            const w = sprite[0]?.length || h;
            
            // Draw background circle
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--detail');
            ctx.beginPath();
            const cx = offsetX + (w/2) * PIXEL_SCALE;
            const cy = offsetY + (h/2) * PIXEL_SCALE;
            const radius = 0.75 * w * PIXEL_SCALE; // scale with sprite size
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();

            // Draw a simple litter box on the right with dirt based on litter level
            if (currentPet) {
                const dirt = currentPet.litter_dirt || 0;
                const boxX = 310, boxY = 210, boxW = 70, boxH = 32;
                // box base
                ctx.fillStyle = '#6a5636';
                ctx.fillRect(boxX, boxY, boxW, boxH);
                // surface
                ctx.fillStyle = '#a48e5a';
                ctx.fillRect(boxX + 4, boxY + 6, boxW - 8, boxH - 10);
                // dirt blobs proportional to dirtiness
                const blobs = Math.floor(dirt / 10);
                ctx.fillStyle = '#5b4c2d';
                for (let i = 0; i < blobs; i++) {
                    const rx = boxX + 8 + (i * 8) % (boxW - 16);
                    const ry = boxY + 12 + (i * 5) % (boxH - 18);
                    ctx.fillRect(rx, ry, 6, 4);
                }
            }

            // Draw sprite shadow
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--detail');
            sprite.forEach((row, y) => {
                row.forEach((pixel, x) => {
                    if (pixel) {
                        ctx.fillRect(
                            offsetX + x * PIXEL_SCALE,
                            offsetY + y * PIXEL_SCALE + 4,
                            PIXEL_SCALE,
                            PIXEL_SCALE
                        );
                    }
                });
            });

            // Draw sprite
            sprite.forEach((row, y) => {
                row.forEach((pixel, x) => {
                    if (pixel) {
                        const col = colorFor(pixel);
                        if (col){
                            ctx.fillStyle = col;
                            ctx.fillRect(
                                offsetX + x * PIXEL_SCALE,
                                offsetY + y * PIXEL_SCALE,
                                PIXEL_SCALE,
                                PIXEL_SCALE
                            );
                        }
                    }
                });
            });

            // Draw whiskers overlay (white lines), skip during lick for clarity
            if (currentAnim.name !== 'eat' && currentAnim.name !== 'lick'){
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--text');
                ctx.lineWidth = 2;
                const wy = offsetY + 9 * PIXEL_SCALE;
                // left whiskers
                ctx.beginPath();
                ctx.moveTo(offsetX + 9*PIXEL_SCALE, wy);
                ctx.lineTo(offsetX + 6*PIXEL_SCALE, wy);
                ctx.moveTo(offsetX + 9*PIXEL_SCALE, wy + 3);
                ctx.lineTo(offsetX + 6*PIXEL_SCALE, wy + 3);
                ctx.stroke();
                // right whiskers
                ctx.beginPath();
                ctx.moveTo(offsetX + 14*PIXEL_SCALE, wy);
                ctx.lineTo(offsetX + 17*PIXEL_SCALE, wy);
                ctx.moveTo(offsetX + 14*PIXEL_SCALE, wy + 3);
                ctx.lineTo(offsetX + 17*PIXEL_SCALE, wy + 3);
                ctx.stroke();
            }

            // Action overlays
            if (currentAnim.name === 'discipline') {
                // red exclamation above head
                ctx.fillStyle = '#e74c3c';
                const exX = offsetX + (w/2 - 0.5) * PIXEL_SCALE;
                const exY = offsetY + (2) * PIXEL_SCALE;
                ctx.fillRect(exX, exY, PIXEL_SCALE, PIXEL_SCALE*2);
                ctx.fillRect(exX, exY + PIXEL_SCALE*2.5, PIXEL_SCALE, PIXEL_SCALE);
            } else if (currentAnim.name === 'attention') {
                // hearts
                const heart = (hx, hy) => {
                    ctx.fillStyle = '#ff6b81';
                    ctx.fillRect(hx, hy, PIXEL_SCALE, PIXEL_SCALE);
                    ctx.fillRect(hx+PIXEL_SCALE, hy, PIXEL_SCALE, PIXEL_SCALE);
                    ctx.fillRect(hx-PIXEL_SCALE/2, hy+PIXEL_SCALE, PIXEL_SCALE*2, PIXEL_SCALE);
                    ctx.fillRect(hx, hy+PIXEL_SCALE*2, PIXEL_SCALE, PIXEL_SCALE);
                };
                heart(offsetX + 10*PIXEL_SCALE, offsetY + 2*PIXEL_SCALE);
                heart(offsetX + 13*PIXEL_SCALE, offsetY + 1*PIXEL_SCALE);
            } 
            if (currentAnim.name === 'sick' || (currentPet && currentPet.sick)) {
                // red cross near head to indicate sickness
                ctx.fillStyle = '#ff3b30';
                const cx0 = offsetX + 5*PIXEL_SCALE;
                const cy0 = offsetY + 4*PIXEL_SCALE;
                ctx.fillRect(cx0, cy0 + PIXEL_SCALE, PIXEL_SCALE*3, PIXEL_SCALE);
                ctx.fillRect(cx0 + PIXEL_SCALE, cy0, PIXEL_SCALE, PIXEL_SCALE*3);
            }
        }

        function updateStats(pet) {
            document.getElementById('hungerBar').style.width = `${pet.hunger}%`;
            document.getElementById('happinessBar').style.width = `${pet.happiness}%`;
            document.getElementById('energyBar').style.width = `${pet.energy}%`;
            document.getElementById('litterBar').style.width = `${pet.litter_dirt || 0}%`;
            
            const canvas = document.getElementById('petCanvas');
            canvas.classList.toggle('alive', pet.alive);
            
            // Update day display
            const dayEl = document.getElementById('dayDisplay');
            if (dayEl && pet.current_day) {
                dayEl.textContent = `Day ${pet.current_day}`;
            }
            
            if (pet.sick) {
                showMessage('Your cat feels sick. Try Sick Care.');
            }
        }

        function setAnimation(name, opts={}){
            const def = ANIMS[name] || ANIMS.idle;
            currentAnim.name = name;
            currentAnim.frames = def.frames.slice();
            currentAnim.idx = 0;
            currentAnim.loop = opts.loop ?? def.loop ?? false;
            currentAnim.frameMs = opts.ms ?? def.ms ?? 200;
            currentAnim.lastT = 0;
            currentAnim.until = opts.durationMs ? performance.now() + opts.durationMs : 0;
        }

        function pickIdleByPet(){
            if (!currentPet || !currentPet.alive) return 'idle';
            if (currentPet.energy < 20) return 'sleep';
            if (currentPet.happiness > 70) return 'tail';
            return 'idle';
        }

        function scheduleRandomIdle(){
            nextIdleAt = performance.now() + (4000 + Math.random()*6000);
        }

        function showMessage(msg) {
            const el = document.getElementById('messages');
            el.textContent = msg;
            setTimeout(() => {
                if (el.textContent === msg) {
                    el.textContent = '';
                }
            }, 3000);
        }

        // API calls
        async function getStatus() {
            const response = await fetch('/api/status');
            currentPet = await response.json();
            updateStats(currentPet);
            return currentPet;
        }

        async function feed() {
            const response = await fetch('/api/feed');
            const result = await response.json();
            if (result.error) {
                showMessage(result.error);
            } else {
                sfx('feed');
                setAnimation('eat', { loop:false });
                getStatus();
            }
        }

        async function play() {
            const response = await fetch('/api/play');
            const result = await response.json();
            if (result.error) {
                showMessage(result.error);
            } else {
                sfx('play');
                setAnimation('play', { loop:false });
                getStatus();
            }
        }

        async function sleep() {
            const response = await fetch('/api/sleep');
            const result = await response.json();
            if (result.error) {
                showMessage(result.error);
            } else {
                sfx('sleep');
                setAnimation('sleep', { loop:true });
                getStatus();
            }
        }

        async function clean() {
            const response = await fetch('/api/clean');
            const result = await response.json();
            if (result.error) {
                showMessage(result.error);
            } else {
                sfx('clean');
                getStatus();
            }
        }

        async function discipline() {
            const response = await fetch('/api/discipline');
            const result = await response.json();
            if (result.error) {
                showMessage(result.error);
            } else {
                sfx('discipline');
                setAnimation('discipline', { loop:false });
                getStatus();
            }
        }

        async function attention() {
            const response = await fetch('/api/attention');
            const result = await response.json();
            if (result.error) {
                showMessage(result.error);
            } else {
                sfx('attention');
                setAnimation('attention', { loop:false });
                getStatus();
            }
        }

        async function sickcare() {
            const response = await fetch('/api/sickcare');
            const result = await response.json();
            if (result.error) {
                showMessage(result.error);
            } else {
                sfx('sick');
                setAnimation('sick', { loop:false });
                getStatus();
            }
        }

        async function save() {
            const response = await fetch('/api/save', {
                method: 'POST'
            });
            const data = await response.json();
            const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tomodachi.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function load() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                const text = await file.text();
                const data = JSON.parse(text);
                await fetch('/api/load', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(data)
                });
                getStatus();
            };
            input.click();
        }

        function showHelp() {
            alert(
                "Welcome to Tomodachi!\n\n" +
                "Take care of your virtual pet:\n" +
                "- Feed when hungry\n" +
                "- Play to make happy\n" +
                "- Let it sleep when tired\n" +
                "- Clean the litter box when dirty\n\n" +
                "The better you care for your pet, the longer it will live!"
            );
        }

        // Simple WebAudio-based sound effects
        function ensureAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            return audioCtx;
        }

        function beep(freq = 440, duration = 0.12, type = 'sine', gain = 0.05) {
            const ac = ensureAudio();
            const osc = ac.createOscillator();
            const g = ac.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            g.gain.value = gain;
            osc.connect(g).connect(ac.destination);
            const now = ac.currentTime;
            osc.start(now);
            osc.stop(now + duration);
        }

        function sfx(kind) {
            // small ear-pleasing sequences for each action
            if (kind === 'feed') {
                beep(523.25, 0.08); setTimeout(()=>beep(659.25, 0.1), 90);
            } else if (kind === 'play') {
                beep(784, 0.06, 'square'); setTimeout(()=>beep(880, 0.06, 'square'), 70); setTimeout(()=>beep(988, 0.08, 'square'), 140);
            } else if (kind === 'sleep') {
                beep(392, 0.12, 'sine'); setTimeout(()=>beep(329.6, 0.12, 'sine'), 130);
            } else if (kind === 'clean') {
                beep(440, 0.05, 'triangle'); setTimeout(()=>beep(660, 0.05, 'triangle'), 60);
            } else if (kind === 'discipline') {
                beep(220, 0.06, 'square'); setTimeout(()=>beep(330, 0.06, 'square'), 60);
            } else if (kind === 'attention') {
                beep(660, 0.06, 'sine'); setTimeout(()=>beep(880, 0.06, 'sine'), 70);
            } else if (kind === 'sick') {
                beep(300, 0.08, 'triangle'); setTimeout(()=>beep(520, 0.08, 'triangle'), 100);
            }
        }

        // Animation loop
        function updateDisplay() {
            const canvas = document.getElementById('petCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // if dead, draw dead frame and stop anim updates
            if (currentPet && !currentPet.alive){
                drawSpriteFrame(ctx, SPRITES.dead);
            } else {
                // advance animation
                const now = performance.now();
                if (currentAnim.lastT === 0) currentAnim.lastT = now;
                if (now - currentAnim.lastT >= currentAnim.frameMs){
                    currentAnim.lastT = now;
                    currentAnim.idx++;
                    if (currentAnim.idx >= currentAnim.frames.length){
                        if (currentAnim.loop){ currentAnim.idx = 0; }
                        else { setAnimation(pickIdleByPet()); }
                    }
                }
                // maybe trigger random idle behavior
                if (now >= nextIdleAt){
                    const choices = ['tail','lick','stretch','ears','knead'];
                    const choice = choices[Math.floor(Math.random()*choices.length)];
                    setAnimation(choice, { loop:false });
                    scheduleRandomIdle();
                }
                // draw current frame
                const frameName = currentAnim.frames[currentAnim.idx] || 'cat_idle';
                const frame = SPRITES[frameName] || SPRITES.cat_idle;
                drawSpriteFrame(ctx, frame);
            }

            animationFrame = requestAnimationFrame(updateDisplay);
        }

        // Birth animation: show egg hatching and prompt for name
        async function showBirthAnimation() {
            return new Promise((resolve) => {
                // Create overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.85); z-index: 9999;
                    display: flex; flex-direction: column;
                    align-items: center; justify-content: center;
                    animation: fadeIn 0.5s;
                `;
                
                const content = document.createElement('div');
                content.style.cssText = `
                    background: white; padding: 40px; border-radius: 20px;
                    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                    text-align: center; max-width: 400px;
                `;
                
                content.innerHTML = `
                    <div style="font-size: 64px; margin-bottom: 20px; animation: bounce 1s infinite;">ü•ö</div>
                    <h2 style="color: #222; margin: 20px 0;">A new friend is born!</h2>
                    <p style="color: #666; margin-bottom: 30px;">What will you name your kitten?</p>
                    <input type="text" id="petNameInput" placeholder="Enter name..." 
                        style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #ddd; 
                        border-radius: 8px; margin-bottom: 20px; box-sizing: border-box;">
                    <button id="startButton" style="background: linear-gradient(90deg, #ff7ab6, #6c63ff); 
                        color: white; border: none; padding: 14px 32px; border-radius: 12px; 
                        font-size: 16px; cursor: pointer; box-shadow: 0 4px 12px rgba(108,99,255,0.3);">
                        Begin Adventure!
                    </button>
                `;
                
                overlay.appendChild(content);
                document.body.appendChild(overlay);
                
                // Add keyframes for animations
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
                    @keyframes bounce {
                        0%, 100% { transform: translateY(0); }
                        50% { transform: translateY(-10px); }
                    }
                `;
                document.head.appendChild(style);
                
                const input = document.getElementById('petNameInput');
                const button = document.getElementById('startButton');
                
                input.focus();
                
                const createPet = async () => {
                    const name = input.value.trim() || 'Tomo';
                    
                    // Animate egg hatching
                    content.querySelector('div').textContent = 'üê±';
                    content.querySelector('h2').textContent = `Welcome, ${name}!`;
                    content.querySelector('p').textContent = 'Taking good care of your pet...';
                    input.style.display = 'none';
                    button.style.display = 'none';
                    
                    // Create new pet with chosen name
                    await fetch('/api/new', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ name })
                    });
                    
                    // Fade out overlay
                    setTimeout(() => {
                        overlay.style.animation = 'fadeOut 0.5s';
                        overlay.style.opacity = '0';
                        setTimeout(() => {
                            document.body.removeChild(overlay);
                            resolve();
                        }, 500);
                    }, 1500);
                };
                
                button.addEventListener('click', createPet);
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') createPet();
                });
            });
        }

        // Initialize
        window.onload = async () => {
            initSprites();
            
            // Check if this is a new pet (day 1 or no pet yet) - show birth animation
            const checkResp = await fetch('/api/status');
            const checkData = await checkResp.json();
            
            if (!checkData.current_day || checkData.current_day === 1) {
                // Show birth animation and name prompt
                await showBirthAnimation();
            }
            
            await getStatus();
            setAnimation(pickIdleByPet(), { loop:true });
            scheduleRandomIdle();
            updateDisplay();

            // Update stats periodically
            setInterval(getStatus, 5000);

            // Live clock
            const clockEl = document.getElementById('clock');
            const updateClock = () => {
                const d = new Date();
                clockEl.textContent = d.toLocaleTimeString();
            };
            updateClock();
            setInterval(updateClock, 1000);

            // Unlock WebAudio on first user gesture to avoid autoplay denial
            const unlock = () => {
                try {
                    ensureAudio();
                    if (audioCtx && audioCtx.state === 'suspended' && audioCtx.resume) {
                        audioCtx.resume();
                    }
                } catch (e) { /* ignore */ }
                window.removeEventListener('click', unlock);
                window.removeEventListener('touchstart', unlock);
                window.removeEventListener('keydown', unlock);
            };
            window.addEventListener('click', unlock, { once: true });
            window.addEventListener('touchstart', unlock, { once: true });
            window.addEventListener('keydown', unlock, { once: true });

            // Bezel click (device) sound
            function bezelClick(){
                try{
                    const ac = ensureAudio();
                    const o = ac.createOscillator();
                    const g = ac.createGain();
                    o.type = 'square'; o.frequency.value = 880;
                    g.gain.value = 0.06;
                    o.connect(g).connect(ac.destination);
                    const now = ac.currentTime; o.start(now); o.stop(now + 0.06);
                }catch(e){/* ignore */}
            }

            // LED helpers
            function setLed(id, on){
                const el = document.getElementById(id);
                if (!el) return;
                el.style.background = on ? '#ffef6b' : '#2b3a6f';
                el.style.boxShadow = on ? '0 4px 8px rgba(255,239,107,0.3) inset' : 'none';
            }

            // Long-press helper: short press callback, long press callback
            function attachLongPress(el, shortCb, longCb, ms=600){
                let timer = null;
                const start = (e)=>{ timer = setTimeout(()=>{ timer=null; longCb(e); }, ms); };
                const end = (e)=>{ if (timer){ clearTimeout(timer); timer=null; shortCb(e); } };
                el.addEventListener('touchstart', start, {passive:true});
                el.addEventListener('mousedown', start);
                el.addEventListener('touchend', end);
                el.addEventListener('mouseup', end);
                el.addEventListener('mouseleave', ()=>{ if (timer){ clearTimeout(timer); timer=null; } });
            }

            // Dev toggle UI call
            async function toggleDevFast(){
                try{
                    const r = await fetch('/api/dev/toggle_fast', {method:'POST', headers:{'Content-Type':'application/json'}});
                    const j = await r.json();
                    showMessage('Dev fast-days: ' + (j.dev_fast_days ? 'ON' : 'OFF'));
                    setLed('led-center', j.dev_fast_days);
                }catch(e){ console.warn(e); }
            }

            // wire up shell buttons and LED behavior
            const setupShellButtons = () => {
                const left = document.getElementById('btn-left');
                const center = document.getElementById('btn-center');
                const right = document.getElementById('btn-right');
                const dev = document.getElementById('devToggle');

                if (left) attachLongPress(left, ()=>{ bezelClick(); feed(); setLed('led-left', true); setTimeout(()=>setLed('led-left', false), 700); }, ()=>{ showMessage('Discipline'); bezelClick(); discipline(); setLed('led-left', true); setTimeout(()=>setLed('led-left', false), 700); });
                if (center) attachLongPress(center, ()=>{ bezelClick(); play(); setLed('led-center', true); setTimeout(()=>setLed('led-center', false), 700); }, ()=>{ showMessage('Attention'); bezelClick(); attention(); setLed('led-center', true); setTimeout(()=>setLed('led-center', false), 700); });
                if (right) attachLongPress(right, ()=>{ bezelClick(); clean(); setLed('led-right', true); setTimeout(()=>setLed('led-right', false), 700); }, ()=>{ showMessage('Sick Care'); bezelClick(); sickcare(); setLed('led-right', true); setTimeout(()=>setLed('led-right', false), 700); });

                if (dev) dev.addEventListener('click', (e)=>{ bezelClick(); toggleDevFast(); });
            };

            // Setup shell buttons after UI ready
            setupShellButtons();
        };

        // Cleanup
        window.onunload = () => {
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
        };
    </script>
</body>
</html>